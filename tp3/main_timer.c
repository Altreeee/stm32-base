#include "stm32f4xx_rcc.h"
#include "stm32f4xx_tim.h"
#include "GPIO_STM32F4xx.h"

/*pluse=((period+1)*dutycycle)/100-1*/

void TIM4_Initialize(){

	
	TIM_TimeBaseInitTypeDef Struct;
	//RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
	//预分频器
	Struct.TIM_Prescaler=9999;//f/(99+1)=10kHZ/10000=10HZ
	//TIM_CounterMode set to TIM_CounterMode_Up to count from 0 to the value in TIM_Period and then reset to 0.
	//from a smaller number counts to a larger number
	Struct.TIM_CounterMode=TIM_CounterMode_Up;
	//计数周期(数到这个数就从零开始，并产生中断【时钟响的次数】 )
	Struct.TIM_Period=83; 
	//TIM_ClockDivision set to TIM_CKD_DIV1 which means the clock is not divided.
	Struct.TIM_ClockDivision=TIM_CKD_DIV1;
	//void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
	TIM_TimeBaseInit(TIM4,&Struct);
}



/*
	25%: TIM_PLUSE=((8399+1)*25)/100-1=2099
	si TIM_PLUSE>TIM_Period, sortir toujour a 1

	PWM is a signal that is generated by a timer. 
	The PWM signal is output from the timer's output compare channel, 
	but it is not actually output to a pin until the GPIO pin 
	is configured in the appropriate alternate function mode to receive 
	the PWM signal.
*/
void TIM4_PWM_Initialize(){
	TIM_OCInitTypeDef Struct;
	//设置定时器输出模式
	//output high when the counter is less than the value in TIM_Pulse and low otherwise
	
	/*In the timer module, common PWM modes include PWM mode 1 and PWM mode 2.
		TIM_OCMode_PWM2: 向上计数时，在到达TIM_Pulse前为无效电平，到达后则为有效
		TIM_OCMode_PWM1与2相反，到达前为有效电平*/
	Struct.TIM_OCMode=TIM_OCMode_PWM2;
	//enable the PWM output on the corresponding GPIO pin.
	Struct.TIM_OutputState=TIM_OutputState_Enable;
	//低极性=>低电平有效
	Struct.TIM_OCPolarity=TIM_OCPolarity_Low;
	//设置定时器输出比较通道的占空比，占空比越高，输出脉冲越窄
	//set to 4199 which means a 25% duty cycle output at a 10 kHz update rate.
	Struct.TIM_Pulse=75;//50%=tim_period/2(计数周期数字的一半，也意味着时钟响的次数)
	
	
	// pour configurer la sortie PWM Output Compare 4
	TIM_OC4Init(TIM4, &Struct);
	//pour activer la fonctionnalit PWM.
	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);
	//4 is down blue
	
	
	Struct.TIM_Pulse=8;
	//initilize the output comparison channel 1
	TIM_OC1Init(TIM4, &Struct);
	//Enable the preload feature for output comparison channel 1. 
	//In this configuration, the new comparison value does not take effect immediately, 
	//but is loaded into the comparison register only when the timer's next update event, such as a counter overflow, occurs.
	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
	//1 is left yellow
}







//alternate function mode: 复用模式	
//In the alternate function mode, the GPIO pin can be configured to perform other functions 
//besides its default digital input/output function. 
//在使用PWM功能时，定时器的输出引脚需要与特定的GPIO复用功能绑定
void GPIO_AF_Initialize(void) {
   
    // Enable the peripheral clock for GPIOA
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);   
    // Configure GPIOA Pin 6 as Alternate Function mode (AF2 for TIM4)
		
		//Connect to a comparison channel,Which one is determined based on the pin mapping
		GPIO_PinAF(GPIOD, 15, GPIO_AF_TIM4);   
    GPIO_PinConfigure(GPIOD, 15, GPIO_MODE_AF, GPIO_OUTPUT_PUSH_PULL, GPIO_OUTPUT_SPEED_100MHz, GPIO_NO_PULL_UP_DOWN);
		//4
		GPIO_PinAF(GPIOD, 12, GPIO_AF_TIM4);   
    GPIO_PinConfigure(GPIOD, 12, GPIO_MODE_AF, GPIO_OUTPUT_PUSH_PULL, GPIO_OUTPUT_SPEED_100MHz, GPIO_NO_PULL_UP_DOWN);
		//1
	
	/*
	GPIO_PinAF(GPIOD, 14, GPIO_AF_TIM4);   
    GPIO_PinConfigure(GPIOD, 14, GPIO_MODE_AF, GPIO_OUTPUT_PUSH_PULL, GPIO_OUTPUT_SPEED_100MHz, GPIO_NO_PULL_UP_DOWN);
	  //3
	  GPIO_PinAF(GPIOD, 13, GPIO_AF_TIM4);   
    GPIO_PinConfigure(GPIOD, 13, GPIO_MODE_AF, GPIO_OUTPUT_PUSH_PULL, GPIO_OUTPUT_SPEED_100MHz, GPIO_NO_PULL_UP_DOWN);
		//2
	*/
}

	
int main(){
	TIM4_Initialize();
	TIM4_PWM_Initialize();
	

	
	//start using the TIM_CMD
	TIM_Cmd(TIM4,ENABLE);
	
	
	GPIO_AF_Initialize();
	while(1){}
}
